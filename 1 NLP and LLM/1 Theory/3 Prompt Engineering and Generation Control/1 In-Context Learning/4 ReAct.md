# ReAct (Reasoning + Acting) в Prompt Engineering

## Что такое ReAct

**ReAct (Reasoning + Acting)** — это техника промпт-инжиниринга, в которой языковая модель **попеременно рассуждает и выполняет действия**, чтобы решать задачи, требующие взаимодействия с внешней средой (например, поиск в базе знаний, вызов API, символьные операции и т.д.).

Она была представлена в статье "ReAct: Synergizing Reasoning and Acting in Language Models" и быстро стала стандартом для интеграции LLM с агентной логикой.

ReAct = **chain-of-thought (reasoning)** + **tool use (actions)**

Пример шаблона:

```
Question: Кто был президентом США в 1980 году?
Thought: Мне нужно выяснить, кто был президентом США в 1980 году. Я поищу в базе знаний.
Action: Search[президент США 1980]
Observation: Рональд Рейган был избран в 1980, вступил в должность в 1981. Джимми Картер был президентом до этого.
Thought: Значит, президентом в 1980 году был Джимми Картер.
Answer: Джимми Картер
```

## Компоненты ReAct

1. **Thought** — промежуточное рассуждение (аналог chain-of-thought)
2. **Action** — вызов инструмента или операции (например, Search, Calc, Lookup)
3. **Observation** — результат действия
4. **Answer** — финальный вывод

## В чём мотивация?

- **Модели галлюцинируют**, когда не умеют получать внешние знания
- **Простой CoT не всегда работает**, если шаг требует внешнего действия (поиска, подсчёта)
- **Отделение reasoning от acting** позволяет улучшить интерпретируемость и дебаг

## Когда ReAct особенно полезен

- Взаимодействие с внешними инструментами (search, calculator, code executor)
- Сложные reasoning задачи: multi-hop QA, math, commonsense
- Создание LLM-агентов: WebGPT, Toolformer, LangChain agents

## Форматы действий

Действия могут быть определены как вызовы инструментов с аргументами. Примеры:

- `Search[запрос]` — вызов поисковика или векторной БД
- `Lookup[сущность]` — справочная проверка
- `Calc[1 + 2 × 3]` — вызов калькулятора
- `Code[сгенерируй Python-код]` — генерация кода

## Примеры промптов с ReAct

### Общий шаблон

```
Ты — умный агент. Отвечай пошагово: рассуждай, выполняй действия, делай выводы. Используй формат:

Question: <вопрос>
Thought: <рассуждение>
Action: <действие>
Observation: <результат>
... (повтор)
Answer: <ответ>
```

### Математика

```
Question: Сколько будет (3 + 4) × 2?
Thought: Надо сначала сложить 3 и 4, потом умножить на 2
Action: Calc[(3 + 4) × 2]
Observation: 14
Answer: 14
```

### Поиск

```
Question: Кто был президентом Франции в 2010 году?
Thought: Надо найти, кто занимал этот пост в 2010 году
Action: Search[президент Франции 2010]
Observation: Николя Саркози был президентом с 2007 по 2012 год
Answer: Николя Саркози
```

## Преимущества ReAct

- **Интерпретируемость** — можно видеть reasoning и действия
- **Контролируемость** — можно внедрять фильтры, правила, ограничения
- **Модульность** — можно легко подключать/менять инструменты
- **Снижение галлюцинаций** — модель меньше выдумывает, больше опирается на observation

## Ограничения

- Требует поддержки внешнего обработчика действий (tool executor)
- Может быть менее эффективен в задачах, где весь контекст уже доступен
- Иногда избыточен, если задача слишком простая

## Где используется

- **LangChain / LlamaIndex agents** — основной агентный шаблон
- **OpenAI Function Calling / Tool use** — концептуально совместимы с ReAct
- **AutoGPT / BabyAGI / AgentGPT** — ReAct-логика под капотом
- **Math / QA / Search задачи** — часто в связке с CoT и external tools

## Практические советы по Prompt Engineering

- Используй явные ключевые слова: `Thought:`, `Action:`, `Observation:` — они действуют как якори
- Добавляй примеры ReAct-сессий в системный prompt — демонстрация формата сильно влияет
- Ограничивай список допустимых Action — чтобы модель не галлюцинировала инструменты
- Для Toolformer-подхода можно автоматически подставлять `Action[...]` и дообучать модель
- Для reasoning-heavy задач можно комбинировать ReAct с Self-Ask, Tree of Thought

