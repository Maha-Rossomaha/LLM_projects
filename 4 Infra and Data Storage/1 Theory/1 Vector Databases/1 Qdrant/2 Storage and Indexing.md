# Storage and Indexing

## 1. Общая архитектура

Qdrant хранит данные в структуре, разделённой на **сегменты**. Сегменты содержат:

* **векторное хранилище** — сами векторы и их индексы,
* **payload‑хранилище** — метаданные для фильтрации и дополнительных условий,
* **id‑mapper** — сопоставление внешних идентификаторов (`point_id`) с внутренними структурами.

Такой дизайн позволяет изолировать операции обновления и удаления, а также эффективно управлять памятью и хранением.

---

## 2. Сегменты

### Что такое сегмент?

* Сегмент — это единица хранения внутри коллекции.
* Каждый сегмент содержит подмножество данных.
* Сегменты могут быть **оптимизированными** (с индексами) или **неоптимизированными** (append‑only, быстрый приём данных).

### Жизненный цикл сегмента

1. **Создание**: при вставке новых данных Qdrant помещает их в сегмент без индексации.
2. **Рост**: по мере накопления данных сегмент увеличивается.
3. **Оптимизация (compaction)**: когда сегмент достигает порогового размера, Qdrant строит для него индексы (например, HNSW для векторов).
4. **Слияние**: небольшие сегменты объединяются в крупные для оптимизации поиска.
5. **Удаление/замена**: устаревшие сегменты помечаются и заменяются новыми.

---

## 3. Векторное хранилище

* Хранит сами векторы и их индексы.
* Поддерживает разные индексы: **HNSW** (по умолчанию), Plain (линейный перебор).
* Индексы настраиваются на уровне коллекции.

Пример настройки HNSW индекса:

```python
from qdrant_client.http import models as rest

hnsw_config = rest.HnswConfigDiff(
    m=16,            # количество связей между вершинами
    ef_construct=100 # trade‑off между скоростью построения и качеством
)

client.update_collection(
    collection_name="docs",
    hnsw_config=hnsw_config
)
```

---

## 4. Payload‑хранилище

* Метаданные (`payload`) хранятся отдельно от векторов.
* Поддерживаются разнообразные типы данных:

  * **строки** (ключевые слова, текстовые поля),
  * **числа** (целые и с плавающей точкой),
  * **булевы значения**,
  * **списки** (массивы значений, например список тегов),
  * **даты и временные метки**,
  * **гео‑координаты** (широта/долгота для геопоиска).
* Для ускорения поиска доступны специализированные индексы: по ключевым словам (KEYWORD), по числовым диапазонам (INTEGER/FLOAT), по датам, а также по гео‑полям. Это позволяет выполнять фильтрацию и комбинированные запросы с высокой скоростью.

Пример создания payload‑индекса:

```python
client.create_payload_index(
    collection_name="docs",
    field_name="lang",
    field_schema=rest.PayloadSchemaType.KEYWORD
)
```

---

## 5. Id‑mapper

* Qdrant хранит `id` каждого point во внутренней структуре.
* Это позволяет:

  * быстро находить записи по ID,
  * корректно обрабатывать удаление и апдейты,
  * синхронизировать разные сегменты.

---

## 6. Dedup на поиске

* Qdrant может хранить одну и ту же точку в нескольких сегментах (например, после апдейтов).
* Чтобы результат поиска был консистентным, движок выполняет **deduplication**:

  * на уровне поиска объединяются кандидаты из сегментов,
  * берётся наиболее актуальная версия `point_id`.

---

## 7. Параметры индексов на уровне коллекции

* Индексы (например, HNSW) настраиваются не на отдельных точках, а на **всей коллекции**.
* Это означает, что:

  * все сегменты в коллекции будут использовать одну схему индексации,
  * параметры (например, `m`, `ef_construct`, `ef_search`) задаются глобально.

Пример обновления параметров поиска:

```python
client.update_collection(
    collection_name="docs",
    hnsw_config=rest.HnswConfigDiff(
        ef_construct=128,
    ),
    optimizers_config=rest.OptimizersConfigDiff(
        default_segment_number=4
    )
)
```