# Query DSL (расширенный)

## 1. Основы Query DSL

- **Query DSL** — декларативный JSON-язык для построения запросов в OpenSearch/Elasticsearch.
- Запрос делится на:
  - **query** — влияет на релевантность (score), используется для полнотекстового поиска.
  - **filter** — не влияет на score, используется для точной фильтрации.

Пример минимального запроса:

```json
GET my_index/_search
{
  "query": {
    "match": {"name": "телефон"}
  }
}
```

---

## 2. Базовые запросы

### 2.1. match\_all и match\_none

- `match_all` — возвращает все документы в индексе. Используется для получения полной выборки, часто вместе с фильтрами, сортировкой или агрегациями.
- `match_none` — всегда возвращает пустой результат, применяется для отладки или построения условных запросов (например, когда нужно явно исключить все документы).

```json
"match_all": {}  
"mаatch_none": {}
```

---

## 3. Полнотекстовые запросы (Full-text queries)

### Общие параметры

- **operator** — оператор объединения токенов в `match`, `multi_match`.
  - `OR` (по умолчанию): документ подходит, если содержит **хотя бы один** из токенов.
  - `AND`: документ должен содержать **все** токены.

```json
"match": {
  "description": {
    "query": "смартфон samsung",
    "operator": "and"
  }
}
```

- **fuzziness** — позволяет находить слова с опечатками.

```json
"match": {
  "name": {
    "query": "samsang",
    "fuzziness": "AUTO"
  }
}
```

---

### 3.1. match

- Анализирует текст (анализатор, токенизация).
- Используется для текстовых полей (`text`).

```json
"match": {
  "description": "смартфон samsung"
}
```

### 3.2. match\_phrase

- Аналогично `match`, но ищет **точную последовательность токенов**.

```json
"match_phrase": {
  "description": "смартфон samsung"
}
```

### 3.3. multi\_match

- Ищет сразу по нескольким полям.
- Поддерживает веса полей (`^2`).

```json
"multi_match": {
  "query": "смартфон",
  "fields": ["name^2", "description"]
}
```

Параметры:

- `type` — стратегия сопоставления:
  - `best_fields` — значение ищется по всем полям, но учитывается только максимальный `_score` из всех. Подходит, если все поля примерно синонимичны (например, `title`, `name`).

  - `most_fields` — значение ищется по всем полям, и все совпадения накапливаются в итоговом `_score`. Уместно, если одно и то же значение может встречаться в разных формах (синонимы, морфология и т.п.).
  - `cross_fields` — все поля трактуются как одно большое поле. Части фразы могут находиться в разных полях. Используется для «распределённого соответствия» (напр. `first_name`, `last_name`).
  
  - `phrase` — как `match_phrase`, но для нескольких полей. Ищет точную последовательность токенов в каждом поле.
  
  - `phrase_prefix` — как `phrase`, но последний токен может быть неполным (prefix-поиск), используется для автодополнения.

---

## 4. Точечные запросы (Term-level queries)

Используются для **неанализируемых полей** (`keyword`, `numeric`, `date`).

### 4.1. term
Поиск по одному точному значению (аналог == в SQL).

```json
"term": {
  "status": "ACTIVE"
}
```

### 4.2. terms (IN-массив)
Поиск по нескольким точным значениям (аналог `IN` в SQL).

```json
"terms": {
  "status": ["ACTIVE", "PENDING"]
}
```

### 4.3. range
Фильтрация по диапазону числовых или временных значений (`gte`, `lte`, `gt`, `lt`).

```json
"range": {
  "price": {
    "gte": 100,
    "lt": 500
  }
}
```

### 4.4. exists
Проверка наличия поля (true, если поле существует и не `null`).

```json
"exists": {
  "field": "price"
}
```

### 4.5. prefix
Поиск по префиксу значения (начинается с...). Быстрее, чем `wildcard`.

```json
"prefix": {
  "sku": "abc"
}
```

### 4.6. wildcard
Поиск по шаблону с `*` (любая последовательность) и `?` (один символ). Дорогая операция на больших индексах.

```json
"wildcard": {
  "name.keyword": "*phone*"
}
```

### 4.7. regex
Поиск по регулярному выражению. Очень затратный, использовать с осторожностью.

```json
"regexp": {
  "sku": "[A-Z]{3}[0-9]{3}"
}
```

---

## 5. constant\_score

- Обёртка для фильтра, которая отключает скоринг.
- Удобно для кэшируемых фильтров.

```json
"constant_score": {
  "filter": {"term": {"brand": "samsung"}},
  "boost": 1.2
}
```

---

## 6. Фильтры vs Запросы

| Характеристика | Query         | Filter             |
| -------------- | ------------- | ------------------ |
| Скоринг        | Да (`_score`) | Нет (`_score = 1`) |
| Кэширование    | Нет           | Да                 |
| Использование  | Full-text     | Фильтрация         |

> Важно: фильтры кэшируются, но если условие динамическое (например, `now()` в range), то кеш бесполезен.

---

## 7. Комбинирование: bool queries

`bool` позволяет комбинировать условия:

- `must` — аналог `AND`, учитывается в скоринге.
- `should` — аналог `OR`, влияет на рейтинг.
- `filter` — как `must`, но без скоринга.
- `must_not` — аналог `NOT`.
- `minimum_should_match` — сколько условий из `should` должны выполняться.

```json
"bool": {
  "must": [
    {"match": {"description": "смартфон"}}
  ],
  "should": [
    {"term": {"brand": "samsung"}},
    {"term": {"brand": "xiaomi"}}
  ],
  "minimum_should_match": 1,
  "must_not": [
    {"term": {"out_of_stock": true}}
  ]
}
```

---

## 8. Сортировка и пагинация

### 8.1. from / size

```json
"from": 0,
"size": 10
```

> Но `from + size` не должен превышать `max_result_window` (по умолчанию 10000).

### 8.2. search\_after

Для глубокой пагинации без ограничения `from + size`. Требует `sort` и уникального поля (например, `_id`).

```json
"sort": ["price", "_id"],
"search_after": [500, "abc123"]
```

### 8.3. PIT (Point-in-Time)

Обеспечивает консистентность между батчами.

Создание PIT:

```json
POST /my_index/_pit?keep_alive=1m
```

Запрос с PIT:

```json
POST /_search
{
  "pit": { "id": "abc...", "keep_alive": "1m" },
  "search_after": ["abc123"]
}
```

### 8.4. Scroll (устаревающий метод)

Используется для полной выгрузки, но устарел в пользу PIT + `search_after`.

```json
POST /my_index/_search?scroll=1m
{
  "size": 1000,
  "query": {"match_all": {}}
}
```

---

## 9. function\_score

Позволяет управлять скорингом:

- `field_value_factor` — скоринг на основе значения поля.
- `random_score` — случайный порядок.
- `script_score` — произвольный скрипт.

**boost_mode** — определяет, как объединяются результаты основного запроса и функций:
- `multiply` (по умолчанию) — умножает `_score` на результат функции.
- `sum` — складывает.
- `replace` — заменяет `_score` значением функции.
`avg`, `max`, `min` — усреднение или выбор экстремальных значений.
  
Используется, чтобы контролировать вклад функций в итоговый скоринг.

```json
"function_score": {
  "query": {"match_all": {}},
  "functions": [
    {
      "field_value_factor": {
        "field": "popularity", 
        "modifier": "log1p"
      }
    }
  ],
  "boost_mode": "sum"
}
```

---

## 10. Highlighting

Подсветка совпадений в тексте.

```json
{
  "query": {"match": {"description": "смартфон"}},
  "highlight": {
    "fields": {
      "description": {}
    }
  }
}
```

Результат будет содержать поле `highlight` с HTML-тегами.

---

## 11. Aggregations (aggs)

Агрегации позволяют получать не документы, а сводные данные по индексам.
- **query** возвращает список документов.
- **aggs** возвращают метрики (среднее, максимум, сумма), статистику распределений или фасеты (разбиения по значениям).
- Используются для аналитики, построения графиков, фильтров и дашбордов.
- Выполняются параллельно с поисковым запросом: можно одновременно искать документы и собирать статистику по ним.
- Вложенные агрегации позволяют строить иерархии (например, сгруппировать по бренду, а внутри — по цене).

```json
{
  "size": 0,
  "query": {"match_all": {}},
  "aggs": {
    "avg_price": {"avg": {"field": "price"}},          // среднее значение цены
    "max_price": {"max": {"field": "price"}},          // максимальная цена
    "brands": {                                        // группировка по брендам
      "terms": {"field": "brand.keyword", "size": 5},
      "aggs": {                                        // вложенная агрегация: средняя цена внутри бренда
        "avg_brand_price": {"avg": {"field": "price"}}
      }
    }
  }
}
```

---

## 12. explain API

Можно запросить объяснение `_score`.

```http
GET my_index/_search?explain=true
```

Или для конкретного документа:

```http
GET my_index/_explain/1
{
  "query": {"match": {"text": "смартфон"}}
}
```

---

## 13. Edge cases

- `match` не находит документ? → поле проиндексировано как `keyword`, а не `text`.
- `term` не работает? → нужно использовать `.keyword`.
- `wildcard`/`regexp` — очень дорогие операции на больших индексах.
- `from + size` слишком большой → используй `search_after` или `scroll`.
- Несортируемое поле? → нужны `doc_values`.
- Фильтры кешируются, но для полей с меняющимся временем (`now`) кэш неэффективен.

---

## 14. Формулы и скоринг

**TF-IDF (classic BM25):**

$$
score = idf(t) \cdot tf(t) \cdot norm(field)
$$

* `tf(t)` — сколько раз термин встречается в документе.
* `idf(t)` — логарифм от обратной частоты термина в документах.
* `norm(field)` — нормализация по длине поля.

> По умолчанию используется **BM25**:

$$
score = idf \cdot \frac{tf \cdot (k_1 + 1)}{tf + k_1 \cdot (1 - b + b \cdot \frac{dl}{avgdl})}
$$

Где:

* `tf` — частота термина,
* `dl` — длина документа,
* `avgdl` — средняя длина,
* `k1`, `b` — параметры (по умолчанию 1.2 и 0.75).