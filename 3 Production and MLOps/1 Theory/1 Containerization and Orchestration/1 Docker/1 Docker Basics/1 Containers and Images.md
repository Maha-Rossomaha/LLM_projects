# Контейнер и образ

**Образ (image)** — это **слоёный неизменяемый шаблон** файловой системы + метаданные запуска (entrypoint/cmd, env, рабочая директория). **Контейнер** — это **запущенный экземпляр образа** с добавленным поверх **Writable Layer** (записываемым слоем) и изоляцией процессов/ресурсов.

```
Образ:  [База (linux + python)] + [слой 1] + [слой 2] + ... (Read‑Only)
Контейнер = Образ (RO) ⊕ Writable Layer (RW)  → единая FS через UnionFS
```

## Слои и UnionFS

- Каждый шаг сборки (инструкция Dockerfile) создаёт **новый слой** (read‑only).
- При запуске контейнера докер **склеивает слои** в единую файловую систему через **UnionFS** (на Linux — драйвер `overlay2`).
- Все слои **кешируются**: если содержимое слоя совпадает, он переиспользуется другими образами.

### Copy‑on‑Write (CoW)

- Когда процесс в контейнере **меняет/удаляет файл**, который лежит в одном из read‑only слоёв, драйвер **копирует** этот файл в Writable Layer и изменяет **копию**.
- Поэтому:
  - Изменения **видны только этому контейнеру** и **пропадают** при его удалении (если не примонтирован том).
  - Несколько контейнеров на одном образе делят read‑only слои **без дублирования**.

## Где «живут» слои

- Linux по умолчанию: `overlay2` в каталоге Docker, обычно `/var/lib/docker/overlay2/`.
- Для каждого слоя есть свои каталоги (`diff/`, `work/`, `merged/`), а также метаданные образов (манифесты, конфигурации).
- Пользователь обычно **не трогает** эти пути вручную: управляем через CLI/Compose/Registry.

## Образ vs Виртуальная машина (VM)

**Общее:** изоляция, переносимость, воспроизводимость окружения.

**Ключевые различия:**

- **Ядро ОС:** контейнер **делит ядро** с хостом (Linux‑kernel namespaces/cgroups). ВМ имеет своё **собственное ядро**.
- **Накладные расходы:** контейнеры стартуют **быстрее**, занимают меньше памяти/диска; ВМ — тяжелее, но сильнее изолированы.
- **Совместимость:** Linux‑контейнеры требуют Linux‑ядро (на Windows/Mac обычно через лёгкую ВМ).

## Мини‑пример

Покажем разницу между **эфемерными изменениями** в контейнере и **персистентными** через том.

#### Скрипт `app.py`

```python
from pathlib import Path
import os

base = Path("/app")
data = Path("/data")

print("PID:", os.getpid())
print("Files in /app:", [p.name for p in base.iterdir()])

# создаём/обновляем счётчик запусков в /data
data.mkdir(exist_ok=True)
counter = data / "run_counter.txt"
if counter.exists():
    n = int(counter.read_text()) + 1
else:
    n = 1
counter.write_text(str(n))
print("Run count (persisted if /data is a volume):", n)

# пишем временный файл в /app (исчезнет при пересоздании контейнера)
(base / "temp_in_image_layer.txt").write_text("hello from container")
print("Wrote /app/temp_in_image_layer.txt (ephemeral)")
```

- После `docker rm` и нового запуска **без** тома — счётчик всегда `1`.
- С примонтированным томом — счётчик растёт между перезапусками/пересборками образа.

## Типичные ошибки

1. **Путать образ и контейнер:** образ — шаблон (RO‑слои), контейнер — процесс с RW‑слоем.
2. **Хранить данные внутри контейнера:** всё пропадёт. Для состояния — используем **тома**/внешние БД.
3. **Ломать кэш слоёв:** частые ADD/RUN «с мусором» → гигантские образы и долгие билды.
4. **Игнорировать совместимость ядра/архитектуры:** Linux‑контейнер ≠ Windows‑ядро, `amd64` ≠ `arm64`.

## Краткий чек‑лист

- Образ = слои (RO). Контейнер = образ + RW‑слой.
- UnionFS (обычно `overlay2`) склеивает слои; изменения идут через **CoW** в RW‑слой.
- Долговечные данные → **тома**, а не внутрь контейнера.
- Следи за порядком команд сборки, чтобы **кеш** работал эффективно.

