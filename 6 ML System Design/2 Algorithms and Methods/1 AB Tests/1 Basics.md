# Основы A/B-тестирования

## 1. Мотивация

A/B-тест — это контролируемый эксперимент: мы **случайно** делим пользователей на **контроль** (A) и **тест** (B), показываем им разные варианты и сравниваем **метрику успеха**. Если разница статистически и практически значима, принимаем решение (раскатать, доработать, отменить).

---

## 2. Контроль и тест

* **Контроль (A)** — текущая версия (baseline).
* **Тест (B)** — вариант с изменением (UI/алгоритм/правила).
* **Единица рандомизации**: кто рандомизируется? (пользователь, сессия, показ, заказ…) — это критически важно для корректной дисперсии и независимости наблюдений.
* **Единица анализа** — на чём считаем метрики (часто совпадает с единицей рандомизации).

---

## 3. Виды экспериментов

* **A/A**: контроль vs контроль. Проверка пайплайна и рандомизации (должно «ничего не найти»). Помогает поймать SRM (sample ratio mismatch) и кривые логи.
* **A/B**: один контроль, один тест. Классика.
* **A/B/n (A/B/C …)**: несколько тестов одновременно. Плюс — быстрее сравнить несколько вариантов, минус — множится риск ложноположительных (нужны корректировки на множественные сравнения или победитель — затем подтверждающий A/B).
* **A/B/C** — частный случай A/B/n с двумя вариантами B и C.

---

## 4. Случайное распределение (random assignment)

* Каждый объект (user/сессия/…) заранее с **равной и независимой** вероятностью попадает в A или B.
* Обеспечивает **сопоставимость групп** по наблюдаемым и ненаблюдаемым факторам (в среднем).
* Практика: хеш от стабильного идентификатора (user_id), закрепление варианта (sticky assignment), логирование долей и проверка **SRM** (фактические доли ≈ целевым).

---

## 5. Основные метрики

Чаще всего выделяют:

* **Conversion Rate (CR)** = (# конверсий) / (# единиц, где конверсия возможна). Бинарная метрика.
* **CTR** = клики / показы. Бинарная на уровне показа; важно не «дабл-каунтить» одного пользователя многократно при анализе.
* **ARPU** = суммарная выручка / число пользователей (может быть с длинным «толстым хвостом»).
* **Retention**, **DAU**, **средний чек**, **время в продукте** и т.д.

Рекомендуется:

* Выбрать **OEC** (overall evaluation criterion) — ключевая метрика принятия решения.
* Дополнительно — **guardrails** (метрики-ограждения), чтобы не ухудшить здоровье системы (ошибки, жалобы, latency).

---

## 6. Ошибки I/II рода, p-value и доверительные интервалы

* **H0**: нет эффекта (μB = μA).
* **H1**: эффект есть (двусторонняя) или «лучше/хуже» (односторонняя).
* **Ошибка I рода (α)**: ложная тревога — отвергли H0, хотя её отвергать нельзя (обычно α=0.05).
* **Ошибка II рода (β)**: пропустили настоящий эффект — не отвергли H0, хотя эффект есть.
* **Мощность (power = 1−β)**: шанс обнаружить эффект нужной величины (часто целят ≥80%).
* **p-value**: вероятность получить статистику «не слабее наблюдаемой», если H0 верна. Малое p-value → данные плохо согласуются с H0.
* **Доверительный интервал (ДИ)**: диапазон правдоподобных значений эффекта. 95% ДИ, не покрывающий 0, обычно согласуется с p<0.05.

## 7. Мини-пример на Python: Welch t-test для непрерывной метрики (ARPU)

```python
import numpy as np
from scipy import stats

# 1) Синтетические данные ARPU (например, выручка на пользователя)
rng = np.random.default_rng(42)
arpu_A = rng.normal(loc=10.0, scale=4.0, size=5000)  # контроль
arpu_B = rng.normal(loc=10.5, scale=4.2, size=5000)  # тест (ожидаем +0.5)

# 2) Описательная статистика
mean_A, mean_B = arpu_A.mean(), arpu_B.mean()
nA, nB = len(arpu_A), len(arpu_B)
print(f"Mean A = {mean_A:.3f}, Mean B = {mean_B:.3f}, diff = {mean_B-mean_A:.3f}")

# 3) Welch t-test (без предположения равенства дисперсий)
t_stat, p_value = stats.ttest_ind(arpu_B, arpu_A, equal_var=False)
print(f"Welch t-test: t = {t_stat:.3f}, p = {p_value:.4f}")

# 4) 95% ДИ для разницы средних (B - A) по Вельчу
var_A = arpu_A.var(ddof=1)
var_B = arpu_B.var(ddof=1)
se = np.sqrt(var_A/nA + var_B/nB)

# Степени свободы по формуле Саттертвейта
df = (var_A/nA + var_B/nB)**2 / ((var_A**2)/((nA**2)*(nA-1)) + (var_B**2)/((nB**2)*(nB-1)))

alpha = 0.05
t_crit = stats.t.ppf(1 - alpha/2, df)
diff = mean_B - mean_A
ci_low, ci_high = diff - t_crit*se, diff + t_crit*se
print(f"95% CI for (B - A): [{ci_low:.3f}, {ci_high:.3f}]")

# 5) Интерпретация (примерно):
# - Если p < 0.05 и 95% ДИ не пересекает 0 => статистически значимый сдвиг.
# - Смотрите на практическую значимость: абсолютный/относительный рост и влияние на OEC.
```

**Если метрика бинарная (например, CR):**
используйте тест разности пропорций (z-тест). Идея: 
$$
    p_1 = x_1/n_1,\; p2 = x2/n2,\\
    p_{pooled} = (x_1+x_2)/(n_1+n_2),\\
    z = (p_2−p_1) / \sqrt{(p_{pooled}*(1−p_{pooled})*(1/n_1 + 1/n_2))},
$$
 p-value — из стандартной нормали.