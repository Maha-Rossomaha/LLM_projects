# Collaborative Filtering: Basics

## 1. Общая классификация

**Коллаборативная фильтрация (CF)** делится на два больших класса:

### 1.1. Memory-based CF (neighbourhood-based, kNN)

* Основана **на явных данных и статистике**:

  * матрица взаимодействий,
  * похожесть пользователей или объектов,
  * агрегирование соседей.
* Не обучает параметризованную модель.
* Прогноз строится напрямую из наблюдений.

Типичные примеры:

* user-based kNN,
* item-based kNN,
* SLIM (Sparse Linear Methods, условно между memory и model).

### 1.2. Model-based CF

* Основана **на обучении модели**:

  * matrix factorization,
  * probabilistic MF,
  * neural CF,
  * autoencoders,
  * GNN (LightGCN и т.п.).
* Лучше масштабируется и обобщает,
* но хуже интерпретируется.

**Важно**: memory-based — это концептуальный предок MF / two-tower / GNN. Все они решают *ту же задачу*, но разными средствами.

---

## 2. User-based vs Item-based CF

### 2.1. User-based CF

**Идея**:

> “Пользователи, похожие на тебя, любят похожие вещи”.

Формально:

* ищем пользователей, похожих на пользователя $u$,
* агрегируем их оценки для айтема $i$.

**Минусы**:

* интересы пользователей **нестабильны во времени**,
* похожесть пользователей быстро деградирует,
* плохо масштабируется (много пользователей).

**Плюс**:

* может давать **неожиданные рекомендации**
  (эффект “люди вроде тебя посмотрели…”).

Исторически важен, но в проде используется редко.

---

### 2.2. Item-based CF

**Идея**:

> “Если тебе понравился этот айтем, тебе понравятся похожие на него”.

* похожесть между айтемами **более стабильна**,
* меньше шум от изменения поведения пользователей,
* легче кешировать и масштабировать.

> **По умолчанию дальше рассматриваем item-based**, если не сказано иначе.

---

## 3. Нотация и постановка задачи

Пусть:

* $U$ — множество пользователей,
* $I$ — множество айтемов,
* $R \in \mathbb{R}^{|U| \times |I|}$ — матрица рейтингов / взаимодействий,
* $r_{ui}$ — известный рейтинг или сигнал.

Обозначения:

* $I_u = { i \mid r_{ui} \text{ известно} }$ — айтемы, с которыми взаимодействовал пользователь $u$,
* $U_i = { u \mid r_{ui} \text{ известно} }$ — пользователи, взаимодействовавшие с айтемом $i$.

Пропущенные значения:

* обычно **не считаются** (а не заменяются на 0),
* 0 допустим только в implicit-feedback постановке и с оговорками.

---

## 4. Общая формула memory-based CF

Прогноз рейтинга $\hat r_{ui}$:

$$
\hat r_{ui} =
\begin{cases}
\text{aggr}_{u' \in U_i} \; r_{u'i} & \text{(user-based)} \\
\text{aggr}_{i' \in I_u} \; r_{ui'} & \text{(item-based)}
\end{cases}
$$

Смысл:

* мы **агрегируем известные рейтинги**,
* чтобы предсказать рейтинг для неизвестной пары $(u, i)$.

---

## 5. Item-based CF: варианты агрегации

### 5.1. Простое усреднение

$$
\hat r_{ui} = \frac{1}{|I_u|} \sum_{i' \in I_u} r_{ui'}
$$

* не использует похожесть,
* почти бесполезно,
* служит baseline’ом.

---

### 5.2. Взвешенное усреднение (item similarity)

$$
\hat r_{ui} = k \sum_{i' \in I_u} \mathrm{sim}(i, i') \cdot r_{ui'}
$$

где нормализация:
$$
k = \frac{1}{\sum_{i' \in I_u} |\mathrm{sim}(i, i')|}
$$

Это **классический item-kNN**.

---

### 5.3. С учётом пользовательского bias

Проблема:

* пользователи используют шкалу рейтингов по-разному
  (кто-то ставит только 4–5, кто-то 2–3).

Решение:
$$
    \hat r_{ui} =
    \bar r_{u_k} + \sum_{i' \in I_u}
    \mathrm{sim}(i, i') \cdot (r_{ui'} - \bar r_u)
$$

где $\bar r_u$ — средний рейтинг пользователя $u$.

> Это **нормировка по пользователю**, а не по айтему
(на картинке часто путают индексы — это типичная опечатка).

---

## 6. Функции похожести $\mathrm{sim}(i, j)$

Обозначим:

* $U_{ij} = U_i \cap U_j$ — пользователи, оценившие оба айтема.

---

### 6.1. Косинусная похожесть

$$
\mathrm{sim}_{\cos}(i, j) = \frac{
\sum_{u \in U_{ij}} r_{ui} \cdot r_{uj}
}{
\sqrt{\sum_{u \in U_{ij}} r_{ui}^2}
\sqrt{\sum_{u \in U_{ij}} r_{uj}^2}
}
$$

* Базовый и самый популярный вариант.
* Чувствителен к популярным айтемам - числитель — сколько пользователей взаимодействовали с обоими айтемами. У популярного айтема это число большое со всеми.
* Не учитывает bias пользователей.

---

### 6.2. Pearson correlation

$$
\mathrm{sim}_{\text{Pearson}}(i, j) = \frac{
\sum_{u \in U_{ij}}
(r_{ui} - \bar r_i)(r_{uj} - \bar r_j)
}{
\sqrt{\sum_{u \in U_{ij}} (r_{ui} - \bar r_i)^2}
\sqrt{\sum_{u \in U_{ij}} (r_{uj} - \bar r_j)^2}
}
$$

где $\bar r_i$ — средний рейтинг айтема $i$.

**Интерпретация**:

* измеряет **согласованность отклонений**,
* лучше работает при разных шкалах.

---

## 7. Поправки для разреженности и популярности

### 7.1. IDF-пере-взвешивание (аналог NLP)

Проблема:

* популярные айтемы доминируют в похожести.

Идея:

* редкие взаимодействия информативнее.

Вес пользователя:
$$
\lambda_u = \log \frac{|I|}{|I_u|}
$$

IDF-взвешенный косинус:

$$
\mathrm{sim}_{\text{IDF}}(i, j) = \frac{
\sum_{u \in U_{ij}} \lambda_u \, r_{ui} r_{uj}
}{
\sqrt{\sum_{u \in U_{ij}} \lambda_u r_{ui}^2}
\sqrt{\sum_{u \in U_{ij}} \lambda_u r_{uj}^2}
}
$$

> Это **прямой перенос TF–IDF идей в CF**.

---

### 7.2. Shrinkage (борьба с шумом)

Проблема:  
Высокая похожесть по 2–3 пользователям — шум: если два айтема ($A$ и $B$) посмотрели одни и те же два человека, то:
* по косинусу/корреляции пересечение будет идеальное, `sim(A, B)=1`  

Однако это ничего не значит:
* Выборка может быть очень маленькой
* Может быть случайность
* Появится новый показатель, и "похожесть" исчезнет

**Shrinkage** - способ штрафования функции схожести за размер выборки.
$$
\mathrm{sim}'(i, j) = \frac{|U_{ij}|}{|U_{ij}| + \beta}
\cdot
\mathrm{sim}(i, j)
$$

* $|U_{ij}|$ - сколько пользователей взаимодействовали с обоими айтемами,
* $\beta \approx 50\text{–}200$ — гиперпараметр,
* “сжимает” оценки с малым числом наблюдений к нулю.

> Обязателен в реальных системах.

---

## 8. User-based CF (симметрично)

Все формулы выше **симметричны**:

* меняем местами $u \leftrightarrow i$,
* считаем похожесть пользователей,
* агрегируем по $U_i$ вместо $I_u$.

**На практике - используется реже.**

### 8.1 Нестабильность похожести пользователей
Пользователи:
* меняют интересы,
* имеют короткую историю,
* сильно зависят от контекста/времени.

Похожесть user–user:
* быстро устаревает,
* сильно шумит,
* требует частого пересчёта.

Item–item:
* более стационарен (айтемы меняются медленнее),
* кластеры устойчивее.

### 8.2 Масштабирование
* Пользователей обычно намного больше, чем айтемов.
* User–user similarity:
  * $O(|U|^2)$ по памяти/вычислениям (или сложные аппроксимации),
  * тяжёлая онлайн-агрегация.

Item–item:
* матрица меньше,
* можно предвычислить,
* быстро работает в онлайне.

### 8.3 Холодный старт
User-based:
* новый пользователь → ноль похожих → ноль сигнала.

Item-based:
* новый пользователь можно обслужить по 1–2 кликам,
* айтемы уже имеют embedding / соседей.

### 8.4 Качество рекомендаций

User-based:
* часто даёт “случайные” рекомендации,
* хорошо ловит редкие, неожиданные совпадения,
* но нестабилен.

Item-based:
* даёт более предсказуемые и воспроизводимые результаты,
* лучше контролируется через shrinkage, popularity penalties.

