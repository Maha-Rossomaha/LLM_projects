# Direct and Inverted Indices

## Direct Index

Прямой индекс — это отображение идентификатора документа (**docID**) в множество его признаков (термов, токенов, эмбеддингов или других характеристик).

Иными словами, прямой индекс хранит **структуру документа в разложенном виде**, где каждому документу соответствует список его признаков.

---

### Основные свойства

1. **Отображение**: `docID → {признаки}`.
2. Используется для **хранения исходных признаков** (токенов, лемм, нормализованных терминов).
3. По прямому индексу формируется множество признаков документов для дальнейшего **ранжирования**.

---

### Пример

Исходные документы:

* Документ 1: «Кошка сидит на окне.»
* Документ 2: «Собака играет в парке.»

**Прямой индекс:**

* Документ 1 → {кошка, сидеть, окно}
* Документ 2 → {собака, играть, парк}

**Инвертированный индекс (для сравнения):**

* кошка → {Документ 1}
* сидеть → {Документ 1}
* окно → {Документ 1}
* собака → {Документ 2}
* играть → {Документ 2}
* парк → {Документ 2}

---

### Роль в поиске

* Прямой индекс является **базой для построения инвертированного индекса**.
* Обеспечивает быстрый доступ ко всем признакам документа.
* Используется при **ранжировании документов**: по набору признаков можно вычислять различные метрики релевантности.

---

## Inverted Index

Обратный индекс (инвертированный) — это структура данных, которая сопоставляет **термин (слово, n-грамму, токен)** с множеством идентификаторов документов, где он встречается.

Иными словами, по термину можно быстро узнать список документов, содержащих его.

---

### Основные свойства

1. **Отображение**: `термин → {docID1, docID2, ...}`.
2. Термины могут быть словами, леммами, n-граммами или иными атомарными единицами.
3. Используется для **поиска кандидатов** документов по одному или нескольким терминам.

---

### Пример

Исходные документы:

* Документ 1: «Продвижение сайта в поисковых системах — это эффективный способ привлечения трафика на сайт.»
* Документ 2: «Большинство услуг по продвижению сайта подразумевают продвижение сайта в Яндексе.»

**Обратный индекс:**

* продвижение → {Документ 1, Документ 2}
* сайт → {Документ 1, Документ 2}
* поисковый → {Документ 1}
* система → {Документ 1}
* эффективный → {Документ 1}
* трафик → {Документ 1}
* большинство → {Документ 2}
* услуга → {Документ 2}
* яндекс → {Документ 2}

---

### Роль в поиске

* Позволяет **быстро находить документы**, содержащие заданные термины.
* Является **базовым источником отбора кандидатов** для дальнейшего ранжирования.
* Оптимизирован для быстрых look-up запросов (поиск по словарю → список документов).

---

## Поиск в обратном индексе

Поиск в обратном индексе сводится к разбору запроса на отдельные термины и построению логического выражения, которое определяет, какие документы удовлетворяют условиям запроса.

---

### Основные шаги

1. **Парсинг запроса**

   * Запрос разбивается на термины (слова, n-граммы).
   * Каждый термин связывается с множеством документов из обратного индекса.

2. **Представление запроса в виде дерева**

   * Внутренние узлы — логические операции (И / ИЛИ).
   * Листья — термины запроса.

3. **Обработка логики**

   * Между всеми терминами по умолчанию вставляется операция **И** (пересечение множеств документов).
   * Операции **ИЛИ** формируются за счёт использования синонимов и расширений запроса.

4. **Использование синонимов**

   * Термины или группы терминов заменяются на синонимы из словаря.
   * Пример: `дед || старик`, `мороз || холод`, `санта && клаус`.
   * Это расширяет множество кандидатов и делает поиск более гибким.

5. **Объединение и пересечение множеств**

   * По каждому термину извлекается множество документов.
   * В соответствии с деревом запроса множества объединяются (`ИЛИ`) или пересекаются (`И`).

---

### Пример

Запрос: «дед мороз»

* Формализация: `((дед || старик) && (мороз || холод)) || (санта && клаус)`
* Синонимы:

  * {дед мороз, санта клаус}
  * {дед, старик}
  * {мороз, холод}

Результат: множество документов, которые содержат комбинации этих терминов.

---

### Итог

Методы поиска в обратном индексе:

* Разбор запроса и выделение терминов.
* Построение дерева логических операций.
* Использование словаря синонимов для расширения запроса.
* Пересечение и объединение множеств документов из обратного индекса.

Таким образом формируется множество кандидатов, которые затем подаются на дальнейшее ранжирование.

## Как хранить огромный индекс

### Проблема

Индекс для крупной коллекции документов может занимать десятки терабайт памяти. Полностью загрузить его на одну машину часто невозможно.

---

### Подходы к хранению

1. **Шардирование (разделение на части)**

   * Индекс режется на несколько *шардов*.
   * Каждый шард хранится на отдельном сервере.
   * Кластер обрабатывает запрос, параллельно обращаясь к шардированным копиям.

   Пример: если индекс = 10 ТБ, а сервер вмещает 48 ГБ, потребуется порядка 200 серверов.

2. **Репликация**

   * Каждый шард может иметь копии (реплики) для отказоустойчивости и балансировки нагрузки.

3. **Сжатие**

   * На практике объём индекса уменьшается за счёт эффективных алгоритмов сжатия.
   * Используются:

     * **постинг-листы с gap encoding** (сохраняются разницы между ID вместо самих ID);
     * **сжатие словаря** (prefix-compression);
     * **битовые вектора + run-length encoding**;
     * **блоковое сжатие** (variable-byte coding, PForDelta).
   * В результате реальный объём индекса может быть в несколько раз меньше.

4. **Иерархия хранения**

   * «Горячие» данные (часто используемые термины) хранятся в оперативной памяти (RAM).
   * «Холодные» данные — на SSD или HDD.
   * Для архивных частей индекса — распределённые файловые системы (HDFS, S3).

---

### Итог

Хранение огромного индекса решается комбинацией:

* **шардирования** (разделение на части по кластеру);
* **репликации** (надёжность и балансировка);
* **сжатия** (уменьшение размера в 3–10 раз);
* **иерархии хранения** (RAM + SSD + HDD + объектное хранилище).

Такой подход позволяет обслуживать поисковые системы с объёмами в десятки и сотни терабайт индекса.

---

## Формулы над обратным индексом

Формулы над обратным индексом позволяют оценивать релевантность документов запросу. Это функции, которые по статистическим признакам (частоты, длина документа, количество документов с термином) вычисляют числовой скор. Документы затем сортируются по этому скору.

---

### Особенности

1. **Работаем через обратный индекс**

   * В прямой индекс ходить дорого (он сжат и хранит весь документ).
   * В обратный индекс ходить дёшево: это отображение термина в список документов.

2. **Формулы ранжирования**

   * Чаще всего это линейные модели над счётчиками (частотами, нормализациями).
   * Основные признаки: Term Frequency (TF), Inverse Document Frequency (IDF), длина документа, нормализация.

3. **Пример: полнотекстовый поиск**

   * Построен поверх обратного индекса.
   * Классический пример: **BM25**.

---

### BM25

Формула:

$$
BM25(D, q) = \frac{f(q, D) \cdot (k+1)}{f(q, D) + k \cdot (1 - b + b \cdot \frac{|D|}{avgdl})} \cdot \log \frac{N - n_q + 0.5}{n_q + 0.5}
$$

Где:

* $f(q, D)$ — частота термина $q$ в документе $D$ (TF).
* $|D|$ — длина документа.
* $avgdl$ — средняя длина документов в коллекции.
* $N$ — общее количество документов.
* $n_q$ — количество документов, содержащих термин $q$.
* $k, b$ — параметры сглаживания.
  * k - параметр, решулирующий насыщение частоты термина (TF):
    * При $k \to 0$: вес термина слабо зависит от его частоты
    * При $k \to \infty$: вес термина растет линейно с его частотой
    * Обычно $k \in [1.2, 2.0]$
  * b - параметр, который контролирует влияние длины документа:
    * При $b = 0$: длина документа не учитывается
    * При $b=1$: длина документа полностью учитывается
    * Обычно $b=0.75$
  * Множитель в скобках в знаменателе: длинные документы имеют больше вероятности содержать термины случайно
  * Если документ длиннее среднего, вес снижается, и наоборот

#### Интерпретация

* Левая часть формулы (TF) учитывает, насколько часто термин встречается в документе.
* Правая часть (IDF) показывает важность термина: чем реже он встречается, тем выше его ценность.

---