# Re‑embed и Re‑index

## 0. Картинка мира: что мы вообще мигрируем

Векторный поиск почти всегда выглядит как трёхслойный бутерброд.

1. **Source of truth**. Где живут «настоящие» объекты: товары, посты, документы, пользователи. Это БД/хранилище.
2. **Embedding store**. Таблица/коллекция вида `id → vector + metadata`. Это ещё не индекс, а просто “склад векторов”.
3. **ANN‑index**. Структура для быстрого kNN: HNSW, IVF‑PQ, ScaNN, OpenSearch KNN, Qdrant, Milvus, FAISS‑шарды и т.д.

**Почему важно разделять 2 и 3.**

* Store — про **истину и версионирование** («какой вектор у объекта сейчас»).
* ANN‑index — про **скорость и форму поиска** («как мы быстро находим соседей»).

**Версия (v)** может относиться к разным вещам:

* версия **модели эмбеддингов** (encoder),
* версия **препроцессинга** (chunking, нормализация, язык),
* версия **индекс‑конфига** (параметры HNSW/IVF, шардирование),
* версия **схемы метаданных**.

Когда ты делаешь миграцию, ты на самом деле отвечаешь на вопрос: *«какая часть меняется и как это аккуратно развернуть?»*

---

## 1. Re‑embed и Re‑index: в чём разница и когда что нужно

### 1.1. Re‑embed

**Re‑embed** — это **пересчёт самих векторов** на новую функцию
$$
   f_{\theta_2}: text → R^d
$$

Когда нужно:

* обучили / взяли **новую модель**, которая лучше ловит смысл;
* поменяли **препроцессинг**: другой chunking, фильтрация мусора, нормализация;
* сменили **домен/язык** (например, русскоязычные запросы стали преобладать);
* исправили баг (типа «не тем токенизатором резали»);
* поменяли размерность d.

Интуиция:

* меняется **геометрия пространства**.
* значит, старые расстояния уже “не те”, даже если индекс физически тот же.

### 1.2. Re‑index

**Re‑index** — это **перестройка ANN‑структуры** поверх уже посчитанных векторов.

Когда нужно:

* параметры индекса выбраны плохо (latency высокая или recall низкий);
* переход на другой движок: FAISS → Qdrant / OpenSearch KNN;
* дефрагментация / уплотнение (индекс «раздулся» от апдейтов);
* меняется шардирование или железо.

Интуиция:

* вектора те же, **геометрия та же**, но способ “быстро лазить по пространству” другой.

### 1.3. Мнемоника (очень простая)

* **Если меняется смысл** → Re‑embed.
* **Если меняется только скорость/структура поиска** → Re‑index.

---

## 2. Почему нельзя смешивать версии в одном индексе

Это самый частый и самый дорогой фейл.

Если ты для части объектов уже посчитал `vector_v2`, а для части ещё держишь `vector_v1`, и кладёшь всё в один индекс — ты получаешь **кашу из двух разных геометрий**.

Что ломается:

* косинус/евклид перестаёт быть сопоставимым;
* ближайшие соседи становятся случайными;
* tail‑объекты улетают куда‑то «в космос».

Поэтому правило:

**Две версии пространства → два отдельных индекса.**

---

## 3. Типовой «нулевой даунтайм» пайплайн миграции

Пусть есть `v1`, делаем `v2`.

1. **Поднимаем новое хранилище векторов и новый индекс.**

   * `emb_store_v2` пустой или частично пустой.
   * `index_v2` пока shadow.
2. **Включаем dual‑write.**

   * всё новое/обновлённое пишем в v1 и v2 параллельно.
3. **Batch re‑embed snapshot.**

   * пересчитываем все недостающие v2‑векторы.
4. **Re‑index v2 offline.**

   * строим ANN‑индекс с нужными параметрами.
5. **Shadow‑serve.**

   * гоняем копии реальных запросов на v2, но пользователю не показываем.
6. **Canary traffic.**

   * небольшой % реального трафика уходит на v2.
7. **Alias‑switch.**

   * атомарно переводим 100% трафика на v2.
8. **Отключаем dual‑write для v1 + чистим v1.**

Вся магия миграции — в пунктах 2, 5, 6, 7. Остальное просто вычисления.

---

## 4. Dual‑write ingestion

### 4.1. Что это

Пока ты массово пересчитываешь v2, **мир не стоит на месте**.
Новые товары приезжают, новые посты выходят, пользователи создают новый контент.

Dual‑write — это режим, в котором любой ingest пишет сразу в обе версии:

* `vector_v1` → store_v1 + index_v1
* `vector_v2` → store_v2 + index_v2

### 4.2. Как реализуют

1. **Синхронно**.

   * запрос считается успешным только когда обновлены обе версии.
   * хорошо для консистентности, плохо для latency.

2. **Асинхронно через outbox/очередь.**

   * сервис пишет событие «объект изменился»;
   * воркеры пересчитывают векторы и индексируют в v1/v2.
   * обязательно идемпотентность по `id + version`.

### 4.3. На что смотреть

* lag dual‑write (сколько объектов в v2 отстаёт);
* rate ошибок воркеров;
* нагрузка x2 на embedding‑сервис.

### 4.4. Бизнес‑пример

**Маркетплейс.** Ты пересчитываешь 50M товаров два дня. За эти два дня появилось 300k новых SKU.
Без dual‑write после alias‑switch они просто **исчезнут из поиска** на v2, пока ты не сделаешь ещё один batch.

---

## 5. Shadow‑index

### 5.1. Идея

Shadow‑index — это индекс v2, который **живёт параллельно, но молча**.
Он нужен, чтобы проверить новинку, не ломая прод.

### 5.2. Как проверяем

* На каждый реальный запрос делаем **теневую копию** в v2.
* Логируем:

  * top‑k v1,
  * top‑k v2,
  * latency v2.

Пользователь при этом видит только v1.

### 5.3. Что сравниваем

* overlap@k / Jaccard по выдаче;
* offline‑метрики на лейблах;
* отдельные сегменты (head/mid/tail, регионы, языки).

### 5.4. Бизнес‑пример

**RAG по базе знаний.**
Shadow‑serve показывает: v2 на 20% чаще достаёт правильный документ для вопросов “про тарифы”, но слегка хуже в “про переводы”.
Значит, canary лучше начать именно с тарифного сегмента.

---

## 6. Canary traffic

### 6.1. Идея

Ты даёшь v2 **маленький кусочек реального мира** и смотришь, не взорвётся ли он.

### 6.2. Варианты

1. **Случайная доля пользователей**.

   * 1% → 5% → 25% → 100%.
2. **Сегментный canary**.

   * сначала “безопасные” пользователи или low‑value сегменты.
3. **Запросный canary**.

   * сначала head‑запросы (если важна денежка), либо tail‑запросы (если важна “умность”).

### 6.3. Guardrails

* p95/p99 latency;
* error rate;
* клики/конверсии/GMV/retention;
* жалобы, скрытия, отказы.

### 6.4. Бизнес‑пример

**Модерация / антиспам.**
Canary можно делать не по пользователям, а по “логике принятия решения”: 2% сообщений уходят на v2‑кластеризацию, но удаление ещё идёт по v1. Считаем FP/FN и только потом включаем удаление.

---

## 7. Alias‑switch

### 7.1. Идея

Alias — это **имя‑указатель**.
Например, `items_current`.

Пока ты строишь v2, alias смотрит на `items_v1`.
Когда всё готово — ты одним атомарным движением переключаешь его на `items_v2`.

### 7.2. Требования

* переключение должно быть **атомарным**;
* rollback должен быть быстрым;
* API‑контракт выдачи не меняется внезапно.

### 7.3. Бизнес‑пример

**Поиск вакансий.**
Ночью переключили alias. Если утром p99 выросла на 30% и люди жалуются на “медленно грузится” — откат обратно за минуту.

---

## 8. Cache invalidation и versioned keys

### 8.1. Почему это важно

Если у тебя есть кэш выдачи или кэш векторов, то после перехода на v2 он может продолжать отдавать **старые v1 ответы**.
И у тебя создаётся ощущение: “мы выкатили, но ничего не изменилось”.

### 8.2. Версионируем ключи

Идея простая: версия индекса/модели входит в ключ.

```
knn_key = f"knn:{index_v}:{query_hash}"
emb_key = f"emb:{model_v}:{doc_id}"
```

Можно добавить хэш конфига фильтров и нормализаций.

### 8.3. Как инвалидируем

1. **Lazy**.

   * поменяли версию → старый кэш просто перестали читать.
2. **Eager purge**.

   * при switch массово чистим.
3. **Hybrid**.

   * purge для hot‑ключей, остальное lazy.

### 8.4. Бизнес‑пример

**Рекомендации.**
Кэш top‑N на пользователя живёт 6 часов. Если ключ не версионировать — 6 часов ты не увидишь uplift и нормально не измеришь эффект.

---

## 9. Expiry/TTL (Time To Live) для embedding‑пространства

### 9.1. Зачем вообще TTL

* индексы дорожают; нельзя хранить всё вечно;
* старый контент мешает свежему;
* часть объектов “умерла” (товар снят, пост удалён).

### 9.2. Где ставим TTL

1. **На уровне объектов**.

   * `expires_at` в метаданных.
2. **На уровне версии.**

   * держим v1 ещё 14 дней после switch.
3. **На уровне сегментов.**

   * tail живёт меньше, head дольше.

### 9.3. Тонкость

TTL не должен выбить важные “якоря”.
Иногда старый объект нужен как мост к похожим новым.

### 9.4. Бизнес‑пример

**Новости/шортсы.**
Векторы важны неделю. Ставишь TTL 7–10 дней — и индекс всегда “свежий”, не раздувается.

---

## 10. Уборка старой версии

Ты не удаляешь v1 мгновенно — потому что нужен rollback.
Типичная политика:

1. `t0` — alias‑switch на v2.
2. `t0 + 7d` — выключаем dual‑write в v1.
3. `t0 + 14d` — удаляем index_v1.
4. `t0 + 30d` — удаляем emb_v1.

Сроки подбираются по риску и времени доказательства uplift.